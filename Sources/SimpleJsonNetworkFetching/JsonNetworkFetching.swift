import Foundation
#if os(Linux)
    import FoundationNetworking
#endif

public let defaultStatusCodeSet = Set(200 ... 299)
public let defaultURLRequestCachePolicy = URLRequest.CachePolicy.useProtocolCachePolicy
public let defaultURLRequestTimeoutInterval: TimeInterval = 60.0

public typealias NetworkFetchAndDownload = JsonNetworkFetching & URLSessionDataDelegate & NSObject // URLSessionDownloadDelegate
// public typealias NetworkFetchAndDownload = JsonNetworkFetching & URLSessionDownloadDelegate & NSObject // URLSessionDownloadDelegate

public protocol JsonNetworkFetching: AnyObject {
    var session: URLSession? { get set }

    /// use this but you can't show the progress when downloading data.
    init(session: URLSession)

    /// It should be never used. use init(session:) or init(urlConfig:) instead.
    init()

    /// Use this if you want to download data with progress.
    init(urlConfig: URLSessionConfiguration)
    var downloadTasks: [GenericDownloadDataTask] { get set }
    func download<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet: Set<Int>, cachePolicy: URLRequest.CachePolicy, timeoutInterval: TimeInterval, completionHandler: ((Result<Data, Error>) -> Void)?, progressHandler: ((Double) -> Void)?) -> Result<GenericDownloadDataTask, NetworkFetchingError>
    // var downloadTasks: [GenericDownloadFileTask] { get set }
    // func download<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet: Set<Int>, cachePolicy: URLRequest.CachePolicy, timeoutInterval: TimeInterval, completionHandler: ((Result<URL, Error>) -> Void)?, progressHandler: ((Double) -> Void)?) -> Result<GenericDownloadFileTask, NetworkFetchingError>

    /// This method returns the raw data.
    ///
    /// If you are sure the returned data is json string. you can use `String(decoding: returnedData, as: UTF8.self)` to print out the json string for generator to generate model.
    func request<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet: Set<Int>, cachePolicy: URLRequest.CachePolicy, timeoutInterval: TimeInterval, completionHandler: @escaping (Result<Data, NetworkFetchingError>) -> Void)

    /// The method can return `String` from the response's data.
    func request<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet: Set<Int>, cachePolicy: URLRequest.CachePolicy, timeoutInterval: TimeInterval, completionHandler: @escaping (Result<String, NetworkFetchingError>) -> Void)

    /// This method returns Decodable Model
    ///
    /// The returned Model can be generated by model generator which conforming to Decodable.
    func request<Output: Decodable, T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet: Set<Int>, cachePolicy: URLRequest.CachePolicy, timeoutInterval: TimeInterval, completionHandler: @escaping (Result<Output, NetworkFetchingError>) -> Void)
    static func createRequest<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, cachePolicy: URLRequest.CachePolicy, timeoutInterval: TimeInterval) -> Result<URLRequest, NetworkFetchingError>
    static func decodableDataHandler<Output: Decodable>(error: Error?, response: URLResponse?, data: Data?, statusCodeSet: Set<Int>) -> Result<Output, NetworkFetchingError>
    static func dataHandler(error: Error?, response: URLResponse?, data: Data?, statusCodeSet: Set<Int>) -> Result<Data, NetworkFetchingError>
}

// MARK: - all requests

public extension JsonNetworkFetching {
    func request<T: Encodable>(
        url: URL,
        httpMethod: HTTPMethod<T>,
        statusCodeSet: Set<Int> = defaultStatusCodeSet,
        cachePolicy: URLRequest.CachePolicy = defaultURLRequestCachePolicy,
        timeoutInterval: TimeInterval = defaultURLRequestTimeoutInterval,
        completionHandler: @escaping (Result<Data, NetworkFetchingError>) -> Void
    ) {
        let request: URLRequest
        switch Self.createRequest(url: url, httpMethod: httpMethod, cachePolicy: cachePolicy, timeoutInterval: timeoutInterval) {
        case let .success(returnedrequest):
            request = returnedrequest
        case let .failure(error):
            completionHandler(.failure(error))
            return
        }

        session?.dataTask(with: request) { data, response, error in
            #if os(iOS) // || os(watchOS) //|| os(OSX)
                DispatchQueue.main.async {
                    let result = Self.dataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet)
                    completionHandler(result)
                }
            //            #elseif
            #else
                let result = Self.dataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet)
                completionHandler(result)
            #endif
        }
        .resume()
    }

    func request<T: Encodable>(
        url: URL,
        httpMethod: HTTPMethod<T>,
        statusCodeSet: Set<Int> = defaultStatusCodeSet,
        cachePolicy: URLRequest.CachePolicy = defaultURLRequestCachePolicy,
        timeoutInterval: TimeInterval = defaultURLRequestTimeoutInterval,
        completionHandler: @escaping (Result<String, NetworkFetchingError>) -> Void
    ) {
        let request: URLRequest
        switch Self.createRequest(url: url, httpMethod: httpMethod, cachePolicy: cachePolicy, timeoutInterval: timeoutInterval) {
        case let .success(returnedrequest):
            request = returnedrequest
        case let .failure(error):
            completionHandler(.failure(error))
            return
        }

        session?.dataTask(with: request) { data, response, error in
            #if os(iOS)
                DispatchQueue.main.async {
                    let result = Self.dataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet)
                    switch result {
                    case let .failure(error): completionHandler(.failure(error))
                    case let .success(returnedData): completionHandler(.success(String(decoding: returnedData, as: UTF8.self)))
                    }
                }
            #else
                let result = Self.dataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet)
                switch result {
                case let .failure(error): completionHandler(.failure(error))
                case let .success(returnedData): completionHandler(.success(String(decoding: returnedData, as: UTF8.self)))
                }
            #endif
        }
        .resume()
    }

    func request<Output: Decodable, T: Encodable>(
        url: URL,
        httpMethod: HTTPMethod<T>,
        statusCodeSet: Set<Int> = defaultStatusCodeSet,
        cachePolicy: URLRequest.CachePolicy = defaultURLRequestCachePolicy,
        timeoutInterval: TimeInterval = defaultURLRequestTimeoutInterval,
        completionHandler: @escaping (Result<Output, NetworkFetchingError>) -> Void
    ) {
        let request: URLRequest
        switch Self.createRequest(url: url, httpMethod: httpMethod, cachePolicy: cachePolicy, timeoutInterval: timeoutInterval) {
        case let .success(returnedrequest):
            request = returnedrequest
        case let .failure(error):
            completionHandler(.failure(error))
            return
        }

        session?.dataTask(with: request) { data, response, error in
            #if os(iOS)
                DispatchQueue.main.async {
                    let result: Result<Output, NetworkFetchingError> = Self.decodableDataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet)
                    completionHandler(result)
                }
            #else
                let result: Result<Output, NetworkFetchingError> = Self.decodableDataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet)
                completionHandler(result)
            #endif
        }
        .resume()
    }

    @discardableResult
    func download<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet _: Set<Int> = defaultStatusCodeSet, cachePolicy: URLRequest.CachePolicy = defaultURLRequestCachePolicy, timeoutInterval: TimeInterval = defaultURLRequestTimeoutInterval, completionHandler: ((Result<Data, Error>) -> Void)?, progressHandler: ((Double) -> Void)?) -> Result<GenericDownloadDataTask, NetworkFetchingError> {
        switch Self.createRequest(url: url, httpMethod: httpMethod, cachePolicy: cachePolicy, timeoutInterval: timeoutInterval) {
        case let .failure(error):
            return .failure(error)
        case let .success(request):
            guard let task = session?.dataTask(with: request) else {
                return .failure(.nilSession)
            }
            let downloadTask = GenericDownloadDataTask(task: task, progressHandler: progressHandler, completionHandler: completionHandler)
            downloadTask.resume()
            downloadTasks.append(downloadTask)
            return .success(downloadTask)
        }
    }

    // @discardableResult
    // func download<T: Encodable>(url: URL, httpMethod: HTTPMethod<T>, statusCodeSet _: Set<Int> = defaultStatusCodeSet, cachePolicy: URLRequest.CachePolicy = defaultURLRequestCachePolicy, timeoutInterval: TimeInterval = defaultURLRequestTimeoutInterval, completionHandler: ((Result<URL, Error>) -> Void)?, progressHandler: ((Double) -> Void)?) -> Result<GenericDownloadFileTask, NetworkFetchingError> {
    //     switch Self.createRequest(url: url, httpMethod: httpMethod, cachePolicy: cachePolicy, timeoutInterval: timeoutInterval) {
    //     case let .failure(error):
    //         return .failure(error)
    //     case let .success(request):
    //         guard let task = session?.downloadTask(with: request) else {
    //             return .failure(.nilSession)
    //         }
    //         var downloadTask = GenericDownloadFileTask(task: task)
    //         downloadTask.completionHandler = completionHandler
    //         downloadTask.progressHandler = progressHandler
    //         downloadTask.resume()
    //         downloadTasks.append(downloadTask)
    //         return .success(downloadTask)
    //     }
    // }
}

// MARK: - All Static Helpers

public extension JsonNetworkFetching {
    init(session: URLSession) {
        self.init()
        self.session = session
    }

    /// when wanting to use `GET`, use this static method instead of case `get` of HTTPMethod.
    static func get(headers: [String: String] = [:]) -> HTTPMethod<Stump> {
        return HTTPMethod<Stump>.get(headers: headers)
    }

    static func createRequest<T: Encodable>(url: URL,
                                            httpMethod: HTTPMethod<T>,
                                            cachePolicy: URLRequest.CachePolicy,
                                            timeoutInterval: TimeInterval) -> Result<URLRequest, NetworkFetchingError>
    {
        var request = URLRequest(url: url, cachePolicy: cachePolicy, timeoutInterval: timeoutInterval)

        switch httpMethod.method {
        case type(of: httpMethod).get, type(of: httpMethod).post:
            request.httpMethod = httpMethod.method
        default:
            return .failure(.unknownMethod)
        }
        
        if httpMethod.method == type(of: httpMethod).post, let body = httpMethod.body {
            do {
                let data = try JSONEncoder().encode(body)
                request.httpBody = data
            } catch {
                return .failure(.encodeError(error))
            }
        }

        httpMethod.headers.forEach { request.setValue($0.value, forHTTPHeaderField: $0.key) }
        return .success(request)
    }

    static func decodableDataHandler<Output: Decodable>(error: Error?, response: URLResponse?, data: Data?, statusCodeSet: Set<Int>) -> Result<Output, NetworkFetchingError> {
        let finalData: Data
        switch Self.dataHandler(error: error, response: response, data: data, statusCodeSet: statusCodeSet) {
        case let .failure(networkError):
            return .failure(networkError)
        case let .success(returnData):
            finalData = returnData
        }
        do {
            let decodedResponse = try JSONDecoder().decode(Output.self, from: finalData)
            return .success(decodedResponse)
        } catch {
            return .failure(.decodeError(error, responseData: data))
        }
    }

    static func dataHandler(error: Error?, response: URLResponse?, data: Data?, statusCodeSet: Set<Int>) -> Result<Data, NetworkFetchingError> {
        guard error == nil else {
            return .failure(.networkResponseError(message: error!))
        }
        guard let httpResponse = response as? HTTPURLResponse else {
            return .failure(.notHttpResponse)
        }
        guard statusCodeSet.contains(httpResponse.statusCode) else {
            return .failure(.invalidStatusCode(httpResponse.statusCode, responseData: data))
        }
        guard let data = data else {
            return .failure(.failedToExtractData)
        }
        return .success(data)
    }
}

public extension JsonNetworkFetching where Self: URLSessionDataDelegate {
    init(urlConfig: URLSessionConfiguration) {
        self.init()
        session = URLSession(configuration: urlConfig, delegate: self, delegateQueue: nil)
    }

    /// Step 1. It will be called when starting downloading.
    func urlSession(_: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
        // guard let task = downloadTasks.first(where: { $0.task == dataTask }) else {
        guard let index = downloadTasks.firstIndex(where: { $0.task == dataTask }) else {
            completionHandler(.cancel)
            return
        }
        downloadTasks[index].expectedContentLength = response.expectedContentLength
        completionHandler(.allow)
    }

    /// Step 2. It will be called when downloading and will be called multiple times to update the progress.
    func urlSession(_: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        // guard let task = downloadTasks.first(where: { $0.task == dataTask }) else {
        guard let index = downloadTasks.firstIndex(where: { $0.task == dataTask }) else {
            return
        }
        downloadTasks[index].buffer.append(data)
        let percentageDownloaded = Double(downloadTasks[index].buffer.count) / Double(downloadTasks[index].expectedContentLength)
        #if os(iOS)
            DispatchQueue.main.async {
                downloadTasks[index].progressHandler?(percentageDownloaded)
            }
        #else
            downloadTasks[index].progressHandler?(percentageDownloaded)
        #endif
    }

    /// Step 3. When finishing downloading. It will be called.
    func urlSession(_: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        guard let index = downloadTasks.firstIndex(where: { $0.task == task }) else {
            return
        }
        #if os(iOS)
            DispatchQueue.main.async {
                if let e = error {
                    downloadTasks[index].completionHandler?(.failure(e))
                } else {
                    downloadTasks[index].completionHandler?(.success(downloadTasks[index].buffer))
                }
            }
        #else
            if let e = error {
                downloadTasks[index].completionHandler?(.failure(e))
            } else {
                downloadTasks[index].completionHandler?(.success(downloadTasks[index].buffer))
            }
        #endif
        downloadTasks.remove(at: index)
    }
}

// https://medium.com/swlh/tracking-download-progress-with-urlsessiondownloaddelegate-5174147009f
// public extension JsonNetworkFetching where Self: URLSessionDownloadDelegate {
//     init(urlConfig: URLSessionConfiguration) {
//         self.init()
//         session = URLSession(configuration: urlConfig, delegate: self, delegateQueue: nil)
//     }

//     func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo: URL) {
//         guard let index = downloadTasks.firstIndex(where: { $0.task == downloadTask }) else {
//             return
//         }
//         let task = downloadTasks.remove(at: index)
//         #if os(iOS)
//             DispatchQueue.main.async {
//                 task.completionHandler?(.success(didFinishDownloadingTo))    
//             }
//         #else
//             task.completionHandler?(.success(didFinishDownloadingTo))
//         #endif
//     }

//     func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
//          guard let index = downloadTasks.firstIndex(where: { $0.task == downloadTask }) else {
//             return
//         }
//         let percentageDownloaded = Double(totalBytesWritten / totalBytesExpectedToWrite)
//         #if os(iOS)
//             DispatchQueue.main.async {
//                 downloadTasks[index].progressHandler?(percentageDownloaded)
//             }
//         #else
//             downloadTasks[index].progressHandler?(percentageDownloaded)
//         #endif
//     }

//     // func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset: Int64, expectedTotalBytes: Int64) {

//     // }
// }
